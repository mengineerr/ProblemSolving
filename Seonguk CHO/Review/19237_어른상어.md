# 19237 어른 상어
 ### 문제 요약
> 상어가 있는 공간에서 마지막 상어가 남기 까지의 시간 연산
>
> 상어가 이동을 하며 자신의 위치에 흔적을 남긴다. 상어는 다른 상어의 흔적으로 이동할 수 없다. 즉, 흔적이 없는 공간 혹은 자신이 남긴 흔적으로만 이동 가능.
>
> 이동은 한꺼번에 이루어지며 상어 여럿이 한 공간에 중복되어 위치한 경우 번호가 가장 낮은 상어를 제외한 상어들은 쫓겨난다. 

 ### 문제 풀이 요약
> 문제에서 제시한 방식대로 순차적으로 구현을 하면 해결할 수 있다. 
> 구현의 순서는
> 1. 상어는 자신의 위치에 냄새를 남긴다. 
> 2. 상어는 우선 아무 냄새 없는 칸으로 이동을 하고 그런 칸이 없는 경우 자신의 냄새인 칸으로 이동한다. 이동가능 한 칸이 여럿인 경우 우선순위에 따라 움직인다. 
> 3. 모두 이동을 한 후, 상어의 위치가 중복되는 지를 확인하고 그런 경우 상어를 쫓아낸다. 
> 4. 상기 과정을 반복하여 한마리가 남거나, 1000번의 횟수가 지난 경우 강제 종료
>
> 위의 과정을 구현한 메인 부분은 다음과 같다.
```c++
   while(true){
       if(cnt > 1000){
           ans = -1; break;
       }
       if(total == 1){
           ans = cnt; break;
       }
       cnt++;
       setTrace();
       move(dat);
       updateTrace();
   }
   cout << ans;
```
>
> 상어의 현재 위치와 움직일 다음 위치, 현재 바라보고 있는 방향과 생사 여부를 확인하기 위해 구조체를 선언하였고 각 상어에 대한 정보를 저장하기위해 배열 구조체로 선언함
```c++
struct dat{
    int cx, cy, nx, ny, dir, live;
};

   struct dat dat[MAX*MAX];
   
   or(int i = 0; i < n; i++){
       for(int j = 0; j < n; j++){
           cin >> map[i][j][0];
           if(map[i][j][0] != 0){
               dat[map[i][j][0]].cx = i;
               dat[map[i][j][0]].cy = j;
               dat[map[i][j][0]].live = 1;     // 지도상의 값을 입력하여 배열 구조체의 인덱싱값과 지도에서의 상어 번호를 동일하게 설정함
           }
       }
   }
```

> 이동의 과정은 우선 주변에 냄새가 없는 곳을 확인 후, 이동 방향을 정한다. 방향 탐색 순서는 우선순위에 따라 탐색
```c++
bool chk(int x, int y){
    int nx, ny;
    for(int i = 0; i < 4; i++){
        nx = x + dx[i]; ny = y + dy[i];
        if(0<=nx&&nx<n&&0<=ny&&ny<n){
            if(map[nx][ny][1] == 0){
                return true;
            }
        }
    }
    return false;
}

void move(dat s[MAX*MAX]){
    for(int i = 1; i < m+1; i++){
        dat &a = s[i];   // 상어 정보 접근
        if(a.live == 1){
            if(chk(a.cx,a.cy)){
                // 주변 냄새 없는 것 체크
                // 냄새 없는 곳으로 이동
                }
            }else{
                // 주변 없는 곳 X
                // 본인 냄새로 이동
            }
        }
    }
    // Update
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            map[i][j][0] = 0;
        }  // 모든 이동이 끝난 후 지도를 0으로 초기화
    } 
    for(int i = 1; i < m+1; i++){  // 이후 위치에 따라 이동을 시작하고 상어의 번호는 1부터 시작한다. 
        dat &a = s[i];             // 따라서 이후에 이미 지도에 표시된 곳에 접근한 상어는 쫓겨나게 된다. 
        if(a.live == 0) continue;
        if(map[a.nx][a.ny][0] != 0){
            a.live = 0; total--;  // i가 순차적으로 증가하며 탐색
        }else{
            map[a.nx][a.ny][0] = i;
            a.cx = a.nx; a.cy = a.ny;
        }
    }
}
```
>
> 지도를 3차원으로 설정을 하였음. 0번째는 지도 상태, 1번째는 흔적 주인, 2번째는 잔여 시간.
> 흔적을 업데이트하고 시간 지연하는 부분은 3차원 맵의 값을 변경하는 것으로 구현.

### Comment
- 문제의 주어진 조건을 순차적으로 구현할 줄 알아야한다.
- 따져줘야하는 조건이 많아 구현의 방식이 복잡해지고 변수가 많아질 수 있다. 
- 이를 효율적으로 관리하기 위해 나는 3차원의 맵을 활용 하였고 방향의 우선순위는 vector와 레퍼런스를 사용, 상어의 정보는 배열 구조체를 활용
- 또한, 동시 다발적으로 이동하는 경우이다 보니 각 상어의 정보의 다음 위치를 표시하여 이를 한번에 업데이트 하는 방법을 사용
- 이를 위해 더 효율적인 방법이 있을 지 고민




