# 1520 내리막 길
 ### 문제 요약
> 시작점에서 보다 낮은 지점으로 매번 이동하는 경우에 도착지점까지 이동 가능한 모든 경우의 수를 연산

 ### 문제 풀이 요약
> 일반적인 탐색으로 해결하는 경우 맵 크기가 다른 문제보다 커서 문제를 해결하지 못한다. 
> 이는DP를 적용하여 문제를 해결할 수 있다.
```c++
int sol(int x, int y){
    if(dp[x][y] != -1) return dp[x][y]; // 이미 방문
    if(x == n -1 && y == m -1){
        return 1; // dp 값 업데이트
    }
    int nx, ny;
    dp[x][y] = 0;
    for(int i = 0; i < 4; i++){
        nx = x + dx[i]; ny = y + dy[i];
        if(0<=nx&&nx<n&&0<=ny&&ny<m){
            if(map[x][y] > map[nx][ny]){
                dp[x][y] += sol(nx,ny);
            }
        }
    }
    return dp[x][y];
}
```
> 가장 마지막에 우선적으로 도착하는 경우 모든 경로에 1을 입력하고, 다른 경로에서 해당 경로로 접근하는 경우 지속적으로 새로운 루트가 추가되는 것으로 간주
> 이미 탐색한 부분을 더 이상 탐색하지 않고 기존 루트에 1을 더해주며 새로 추가된 경로가 몇개인지 확인이 가능하다. 

### Comment
- DP를 사용한 탐색
- DP를 모두 -1로 세팅을 한후 한 루트에 들어갔을 때, 0으로 초기화한다. 후에 4방향 탐색후 이동가능한 경로에 재귀형식으로 함수에 접근하고 마지막까지 이 방식을 반복
- dp 값을 저장하는 방식과 값을 읽어오는 방식이 중요





